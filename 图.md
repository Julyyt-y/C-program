图的创建和图的两种遍历方式
=============================

```C

#include <stdio.h> 
#include <stdlib.h>
#define M 20
//边表结点 
typedef struct node{
	int dajvex;				//邻接点 
	struct node *next;
}EdgeNode;
//头结点类型 
typedef struct vnode{
	char vertex;			//顶点信息 
	EdgeNode *FirstEdge;	//邻接链表头指针 
}VertexNode;
//邻接表类型 
typedef struct{
	VertexNode adjlist[M];	//存放头结点的顺序表 
	int n,e;				//图的顶点数与边数 
}LinkedGraph;

int visited[M];

/**
 * 邻接表法创建图 
 * 形参c = 0表示建立一个无向图，否则表示建立一个有向图 
 */
void creat(LinkedGraph *g,char *fileName,int c){
	int i,j,k;
	EdgeNode *s;
	FILE *fp;
	fp = fopen(fileName,"r");
	if(fp){
		fscanf(fp,"%d%d",&g->n,&g->e);
		for(i=0;i<g->n;i++){
			fscanf(fp,"%ls",&g->adjlist[i].vertex);
			g->adjlist[i].FirstEdge = NULL;
		}
		for(k=0;k<g->e;k++){
			fscanf(fp,"%d%d",&i,&j);
			s = (EdgeNode *)malloc(sizeof(EdgeNode));
			s->dajvex = j;
			s->next = g->adjlist[i].FirstEdge;
			g->adjlist[i].FirstEdge = s;
			if(c == 0){
				s = (EdgeNode *)malloc(sizeof(EdgeNode));
				s->dajvex = i;
				s->next = g->adjlist[j].FirstEdge;
				g->adjlist[j].FirstEdge = s;
			}
		}
		fclose(fp);
	}
	else{
		g->n = 0;
	}
}

/**
 * 图的深度优先遍历 
 * 从顶点i开始深度优先遍历图的连通分量 
 * g为图的邻接表，i为遍历起点 
 */
void dfs(LinkedGraph g,int i){
	EdgeNode *p;
	printf("visit vertex: %c \n",g.adjlist[i].vertex);
	visited[i] = 1;
	p = g.adjlist[i].FirstEdge;
	while(p){
		if(!visited[p->dajvex]){
			dfs(g,p->dajvex);
		}
		p = p->next;
	}
} 
/**
 * 图的深度优先遍历 
 * g为图的邻接表 
 */
void DfsTraverse(LinkedGraph g){
	int i;
	for(i=0;i<g.n;i++){
		visited[i] = 0;
	}
	for(i=0;i<g.n;i++){
		if(!visited[i]){
			dfs(g,i);
		}
	}
} 

/**
 * 图的广度优先遍历 
 * 从顶点i出发广度优先遍历图g的连通分量
 * g为图的邻接表，i为遍历始点 
 */
void bfs(LinkedGraph g,int i){
	int j;
	EdgeNode *p;
	int queue[M],front,rear;
	front = rear = 0;
	printf("%c",g.adjlist[i].vertex);
	visited[i] = 1;
	queue[rear++] = i;
	while(rear > front){
		j = queue[front++];
		p = g.adjlist[j].FirstEdge;
		while(p){
			if(visited[p->dajvex] == 0){
				printf("%c",g.adjlist[p->dajvex].vertex);
				queue[rear++] = p->dajvex;
				visited[p->dajvex] = 1;
			}
			p = p->next;
		}
	}
} 
/**
 * 图的广度优先遍历 
 * g为邻接表，返回值为连通分量个数 
 */
int BfsTraverse(LinkedGraph g){
	int i,count = 0;
	for(i=0;i<g.n;i++){
		visited[i] = 0;
	}
	for(i=0;i<g.n;i++){
		if(!visited[i]){
			printf("\n");
			count++;
			bfs(g,i); 
		}
	}
	return count;
} 

int main(){
	LinkedGraph g;
	int count;
	creat(&g,"J:\\gll.txt",0);
	printf("\n The graph is：\n");
	count = BfsTraverse(g);
	printf("该图共有%d个连通分量。\n",count);
	return 0;
}

```
